use std::fs;

use common::{artifacts_dir, zk_apps_dir};
use log::info;
use valence_domain_clients::{
    clients::coprocessor::CoprocessorClient, coprocessor::base_client::CoprocessorBaseClient,
};

const CIRCUIT_NAME: &str = "storage_proof";
const CO_PROCESSOR: &str = "CO-PROCESSOR";

pub async fn deploy_coprocessor_app(
    cp_client: &CoprocessorClient,
    cw20_addr: &str,
) -> anyhow::Result<String> {
    info!(target: CO_PROCESSOR, "deploying coprocessor app...");

    // this can also be done with env passing.
    // not obvious which one is cleaner yet.
    let generated_addr_path = zk_apps_dir()
        .join("storage_proof")
        .join("core")
        .join("src")
        .join("consts.rs");
    let generated_addr_content = format!(
        "// DO NOT EDIT. This file is automatically generated by deploy_coprocessor_app.rs.\npub const CW20_ADDR: &str = \"{cw20_addr}\";",
    );

    fs::write(&generated_addr_path, generated_addr_content)?;
    info!(target: CO_PROCESSOR, "embedded CW20 address into {generated_addr_path:?}");

    // build the artifacts. this puts the resulting binaries under
    // `valence.artifacts` value specified in `valence.toml`.
    nix_build_all().await?;

    // read the build binaries
    let circuit_bytes = read_build_binary(CIRCUIT_NAME, "circuit")?;
    let controller_bytes = read_build_binary(CIRCUIT_NAME, "controller")?;

    let controller_id = cp_client
        .deploy_controller(&controller_bytes, &circuit_bytes, None)
        .await?;

    info!(target: CO_PROCESSOR, "controller_id: {controller_id}");

    Ok(controller_id)
}

fn read_build_binary(circuit_name: &str, binary_name: &str) -> anyhow::Result<Vec<u8>> {
    let coprocessor_artifacts_path = artifacts_dir().join("coprocessor");
    let target_path = coprocessor_artifacts_path
        .join(circuit_name)
        .join(format!("{binary_name}.bin"));

    let target_path_str = target_path.display();

    info!(target: CO_PROCESSOR, "reading binary at path: {target_path_str}");

    if !target_path.exists() {
        anyhow::bail!("{binary_name} binary not found at {target_path_str}");
    }

    let raw_binary = fs::read(&target_path)
        .map_err(|e| anyhow::anyhow!("failed to read {binary_name} from {target_path_str}: {e}"))?;

    info!(target: CO_PROCESSOR, "read {} {binary_name} bytes", raw_binary.len());

    Ok(raw_binary)
}

async fn nix_build_all() -> anyhow::Result<()> {
    info!(target: CO_PROCESSOR, "compiling the zk_apps...");
    let output = tokio::process::Command::new("bash")
        .args(["build-circuits.sh"])
        .output()
        .await?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("Failed to run `nix run`: {stderr}");
    }

    info!(target: CO_PROCESSOR, "build success!");

    Ok(())
}

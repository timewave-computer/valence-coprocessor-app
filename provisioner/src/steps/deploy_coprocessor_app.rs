use std::{fs, path::PathBuf};

use valence_domain_clients::{
    clients::coprocessor::CoprocessorClient, coprocessor::base_client::CoprocessorBaseClient,
};

const CIRCUIT_CONSTS_PATH: &str = "apps/storage_proof/core/src/consts.rs";
const CIRCUIT_NAME: &str = "app";

pub async fn deploy_coprocessor_app(cd: PathBuf, cw20_addr: &str) -> anyhow::Result<String> {
    println!("deploying coprocessor app...");

    // this can also be done with env passing.
    // not obvious which one is cleaner yet.
    let generated_addr_path = cd.join(CIRCUIT_CONSTS_PATH);
    let generated_addr_content = format!(
        "// DO NOT EDIT. This file is automatically generated by deploy_coprocessor_app.rs.\npub const CW20_ADDR: &str = \"{cw20_addr}\";",
    );

    fs::write(&generated_addr_path, generated_addr_content)?;
    println!("embedded CW20 address into {generated_addr_path:?}");

    // build the artifacts. this puts the resulting binaries under
    // `valence.artifacts` value specified in `valence.toml`.
    nix_build_all().await?;

    // read the build binaries
    let circuit_bytes = read_build_binary(CIRCUIT_NAME, "circuit")?;
    let controller_bytes = read_build_binary(CIRCUIT_NAME, "controller")?;

    let cp_client = CoprocessorClient::default();

    let controller_id = cp_client
        .deploy_controller(&controller_bytes, &circuit_bytes, None)
        .await?;

    println!("controller_id: {controller_id}");

    Ok(controller_id)
}

fn read_build_binary(circuit_name: &str, binary_name: &str) -> anyhow::Result<Vec<u8>> {
    const BUILD_ARTIFACTS_PATH: &str = "artifacts/coprocessor/storage_proof";

    let artifacts_base: PathBuf = BUILD_ARTIFACTS_PATH.into();

    let target_path = artifacts_base
        .join(circuit_name)
        .with_file_name(binary_name)
        .with_extension("bin");

    let target_path_str = target_path.display();

    println!("reading binary at path: {target_path_str}");

    if !target_path.exists() {
        anyhow::bail!("{binary_name} binary not found at {target_path_str}");
    }

    let raw_binary = fs::read(&target_path)
        .map_err(|e| anyhow::anyhow!("failed to read {binary_name} from {target_path_str}: {e}"))?;

    println!("read {} {binary_name} bytes", raw_binary.len());

    Ok(raw_binary)
}

async fn nix_build_all() -> anyhow::Result<()> {
    println!("compiling the zk_apps...");
    let output = tokio::process::Command::new("nix")
        .args(["run"])
        .output()
        .await?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("Failed to run `nix run`: {stderr}");
    }

    println!("build success!");

    Ok(())
}

use std::{fs, path::PathBuf};

use valence_domain_clients::{
    clients::coprocessor::CoprocessorClient, coprocessor::base_client::CoprocessorBaseClient,
};

const CIRCUIT_CONSTS_PATH: &str = "circuits/storage_proof/core/src/consts.rs";
const CONTROLLER_PATH: &str = "./circuits/storage_proof/controller";
const CIRCUIT_WORKSPACE_ID: &str = "storage-proof-circuit";

pub async fn deploy_coprocessor_app(cd: PathBuf, cw20_addr: &str) -> anyhow::Result<String> {
    println!("deploying coprocessor app...");

    // this can also be done with env passing.
    // not obvious which one is cleaner yet.
    let generated_addr_path = cd.join(CIRCUIT_CONSTS_PATH);
    let generated_addr_content = format!(
        "// DO NOT EDIT. This file is automatically generated by deploy_coprocessor_app.rs.\n
        pub const CW20_ADDR: &str = \"{cw20_addr}\";",
    );

    fs::write(&generated_addr_path, generated_addr_content)?;
    println!("embedded CW20 address into {generated_addr_path:?}");

    // TODO: build these during runtime
    let circuit_bytes: Vec<u8> = vec![];
    let controller_bytes: Vec<u8> = vec![];

    let cp_client = CoprocessorClient::default();

    let controller_id = cp_client
        .deploy_controller(&controller_bytes, &circuit_bytes, None)
        .await?;

    println!("controller_id: {controller_id}");

    Ok(controller_id)
}

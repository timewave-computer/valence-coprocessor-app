use std::{fs, path::PathBuf};

const CIRCUIT_CONSTS_PATH: &str = "circuits/storage_proof/core/src/consts.rs";
const CONTROLLER_PATH: &str = "./circuits/storage_proof/controller";
const CIRCUIT_WORKSPACE_ID: &str = "storage-proof-circuit";

pub fn deploy_coprocessor_app(cd: PathBuf, cw20_addr: &str) -> anyhow::Result<String> {
    println!("deploying coprocessor app...");

    // this can also be done with env passing.
    // not obvious which one is cleaner yet.
    let generated_addr_path = cd.join(CIRCUIT_CONSTS_PATH);
    let generated_addr_content = format!(
        "// DO NOT EDIT. This file is automatically generated by deploy_coprocessor_app.rs.\n
        pub const CW20_ADDR: &str = \"{cw20_addr}\";",
    );

    fs::write(&generated_addr_path, generated_addr_content)?;
    println!("embedded CW20 address into {generated_addr_path:?}");

    let cargo_valence_app = cargo_valence::App::default();

    let circuit_deployment_response =
        cargo_valence_app.deploy_circuit(Some(CONTROLLER_PATH), CIRCUIT_WORKSPACE_ID)?;

    let controller_id = circuit_deployment_response
        .get("controller")
        .and_then(|v| v.as_str())
        .map(|s| s.to_string())
        .ok_or_else(|| {
            anyhow::anyhow!("failed to extract controller_id from circuit deployment response: {circuit_deployment_response}")
        })?;

    println!("controller_id: {controller_id}");

    Ok(controller_id)
}

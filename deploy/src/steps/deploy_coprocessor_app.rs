use std::{fs, path::PathBuf};

const CIRCUIT_CONSTS_PATH: &str = "circuits/storage_proof/core/src/consts.rs";
const CONTROLLER_PATH: &str = "./circuits/storage_proof/controller";
const CIRCUIT_WORKSPACE_ID: &str = "storage-proof-circuit";

pub fn deploy_coprocessor_app(cd: PathBuf, cw20_addr: &str) -> anyhow::Result<String> {
    println!("deploying coprocessor app...");

    // this can also be done with env passing.
    // not obvious which one is cleaner yet.
    let generated_addr_path = cd.join(CIRCUIT_CONSTS_PATH);
    let generated_addr_content = format!(
        "// DO NOT EDIT. This file is automatically generated by deploy_coprocessor_app.rs.\npub const CW20_ADDR: &str = \"{}\";",
        cw20_addr
    );
    fs::write(&generated_addr_path, generated_addr_content)?;
    println!("embedded CW20 address into {:?}", generated_addr_path);

    let cargo_valence_app = cargo_valence::App::default();

    let circuit_deployment_response =
        cargo_valence_app.deploy_circuit(Some(CONTROLLER_PATH), CIRCUIT_WORKSPACE_ID)?;

    let controller_id = match circuit_deployment_response.as_object() {
        Some(obj) => match obj.get("controller").and_then(|v| v.as_str()) {
            Some(id) => id.to_owned(),
            None => {
                println!("failed to get controller from response object: {obj:?}");
                "deployment_error".to_string()
            }
        },
        None => {
            println!("failed to deploy the circuit: {circuit_deployment_response:?}");
            "deployment_error".to_string()
        }
    };

    println!("controller_id: {controller_id}");

    Ok(controller_id)
}
